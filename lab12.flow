import lingo/pegcode/driver;

Prog(v: [Var], s: [Statement]);
Var(name: string, t: Type);
Type ::= Int, Arr;
Int();
Arr(t: Type);
Statement ::= Assn, Cond, Prnt;
Assn(label: int, varname: string, expr: string, labels: [int]);
Cond(label: int, relationship: string, labels_true: [int], labels_false: [int]);
Prnt(label: int, expr: string, labels: [int]);

make_assn(arg: [flow]) -> flow;
make_assn(arg) {
	varname = arg[0];
	expr = arg[1];
	[Assn(0, varname, expr, [1])];
}

make_cond(arg: [flow]) -> flow;
make_cond(arg) {
	relationship = arg[0];
	[Cond(0, relationship, [1], [])];
}

make_prnt(arg: [flow]) -> flow;
make_prnt(arg) {
	expr = arg[0];
	[Prnt(0, expr, [1])];
}

max_label(arr: [Statement]) -> int;
max_label(arr) {
	lambda = \s: Statement -> {
		switch(s: Statement) {
			Assn(label, varname, expr, labels): max(label, either(maxA(labels), 0));
			Cond(label, relationship, labels_true, labels_false): max(label, either(maxA(concat(labels_true, labels_false)), 0));
			Prnt(label, expr, labels): max(label, either(maxA(labels), 0));
		}
	}
	fold(arr, 0, \ m: int, s: Statement -> max(m, lambda(s)));
}

shift_labels(arr: [Statement], shift: int) -> [Statement];
shift_labels(arr, shift) {
	map(arr, \ s: Statement -> {
		switch(s: Statement) {
			Assn(label, varname, expr, labels): Assn(label+shift, varname, expr, map(labels, \ l: int -> l+shift));
			Cond(label, relationship, labels_true, labels_false): Cond(label+shift, relationship, map(labels_true, \ l: int -> l+shift), map(labels_false, \ l: int -> l+shift));
			Prnt(label, expr, labels): Prnt(label+shift, expr, map(labels, \ l: int -> l+shift));
		}
	});
}
replace_labels(arr: [Statement], old: int, new: int) -> [Statement];
replace_labels(arr, old, new) {
	map(arr, \ s: Statement -> {
		switch(s: Statement) {
			Assn(label, varname, expr, labels): if(label == old) Assn(new, varname, expr, map(labels, \ l: int -> if(l==old) new else l)) else Assn(label, varname, expr, map(labels, \ l: int -> if(l==old) new else l));
			Cond(label, relationship, labels_true, labels_false): if(label == old) Cond(new, relationship, map(labels_true, \ l: int -> if(l==old) new else l), map(labels_false, \ l: int -> if(l==old) new else l)) else Cond(label, relationship, map(labels_true, \ l: int -> if(l==old) new else l), map(labels_false, \ l: int -> if(l==old) new else l));
			Prnt(label, expr, labels): if(label == old) Prnt(new, expr, map(labels, \ l: int -> if(l==old) new else l)) else Prnt(label, expr, map(labels, \ l: int -> if(l==old) new else l));
		}
	});
}

build_sequence(arg: [flow]) -> flow;
build_sequence(arg) {
	arr1 = arg[0];
	arr2 = arg[1];
	concat(arr1, shift_labels(arr2, max_label(arr1)));
}
build_fork(arg: [flow]) -> flow;
build_fork(arg) {
	arr1 = arg[0];
	arr2 = arg[1];
	arr1_shifted = shift_labels(arr1, 1);
	max_arr1_shifted = max_label(arr1_shifted);
	arr2_shifted = shift_labels(arr2, max_arr1_shifted);
	max_arr2_shifted = max_label(arr2_shifted);
	new_cond = Cond(0, "0=0", [1, max_arr1_shifted], []);
	concat(concat([new_cond], replace_labels(arr1_shifted, max_arr1_shifted, max_arr2_shifted)), arr2_shifted);
}
build_iter(arg: [flow]) -> flow;
build_iter(arg) {
	arr = arg[0];
	arr_shifted = shift_labels(arr, 1);
	max_arr_shifted = max_label(arr_shifted);
	new_cond = Cond(0, "0=0", [1, max_arr_shifted], []);
	concat([new_cond], replace_labels(arr_shifted, max_arr_shifted, 0));
}

parse_nemo(s: string) -> Prog;
parse_nemo(s) {
	extendedPegActions = SemanticActions(setTree(setTree(setTree(setTree(setTree(setTree(defaultPegActions.t, "build_sequence", build_sequence), "build_iter", build_iter), "build_fork", build_fork), "make_assn", make_assn), "make_cond", make_cond), "make_prnt", make_prnt));
	parsic(compilePegGrammar("#include lab12.lingo"), s, extendedPegActions);
}

main() {
	sourceExpression = "VAR b : int; VAR a : [int]; PRINT a";
	parsed = parse_nemo(sourceExpression);	
	println(parsed);
}